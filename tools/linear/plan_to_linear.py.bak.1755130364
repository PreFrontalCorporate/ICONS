#!/usr/bin/env python3
import os, json, argparse, sys
import time, random
from tools.linear.linear_client import gql

# ---------- Constants & caches ----------
MAX_LABELS_PAGE = 250  # Linear hard cap per query
LABEL_CACHE = {}       # (lower_name, team_id_or_None) -> label_id

# Capability flags (auto-detected at runtime)
MILESTONES_SUPPORTED = None  # None unknown, True/False determined after first attempt

# ---------- Label helpers ----------
def _prime_label_cache():
    """Fetch all labels (paginated) once; cache by lowercase name + team_id."""
    if LABEL_CACHE:
        return
    cursor = None
    while True:
        q = """
        query($n:Int!, $after:String){
          issueLabels(first:$n, after:$after){
            nodes { id name team { id } }
            pageInfo { hasNextPage endCursor }
          }
        }"""
        data = gql(q, {"n": MAX_LABELS_PAGE, "after": cursor})
        conn = data["issueLabels"]
        for n in conn["nodes"]:
            nm = (n.get("name") or "").strip().lower()
            tid = (n.get("team") or {}).get("id")
            if not nm:
                continue
            LABEL_CACHE[(nm, tid)] = n["id"]
            # Map global labels by (name, None)
            if tid is None:
                LABEL_CACHE[(nm, None)] = n["id"]
        if not conn["pageInfo"]["hasNextPage"]:
            break
        cursor = conn["pageInfo"]["endCursor"]

def label_ids_for(names, team_id):
    """Return de-duplicated label IDs for provided label names (case-insensitive)."""
    if not names:
        return []
    _prime_label_cache()
    out, seen = [], set()
    for name in names:
        key = (name or "").strip().lower()
        lid = LABEL_CACHE.get((key, team_id)) or LABEL_CACHE.get((key, None))
        if lid and lid not in seen:
            out.append(lid); seen.add(lid)
    return out

def ensure_label(name, team_id, color="#7950f2"):
    """Return ID for a label; create it on the team if missing."""
    if not name:
        return None
    _prime_label_cache()
    nm = name.strip().lower()
    lid = LABEL_CACHE.get((nm, team_id)) or LABEL_CACHE.get((nm, None))
    if lid:
        return lid
    q = """
    mutation($input: IssueLabelCreateInput!) {
      issueLabelCreate(input: $input) {
        success
        issueLabel { id name team { id } }
      }
    }"""
    created = gql(q, {"input": {"name": name, "color": color, "teamId": team_id}})["issueLabelCreate"]["issueLabel"]
    lid = created["id"]
    tid = (created.get("team") or {}).get("id")
    LABEL_CACHE[(nm, tid)] = lid
    if tid is None:
        LABEL_CACHE[(nm, None)] = lid
    time.sleep(0.02 + random.random() * 0.03)  # small jitter
    return lid

# ---------- Milestones (schema tolerant) ----------
def _fetch_milestones_page(project_id, after=None):
    """
    Try several schema shapes for fetching milestones.
    Returns a page connection dict with keys: nodes[], pageInfo{hasNextPage,endCursor}
    or None if unsupported.
    """
    # 1) Legacy/variant: project { milestones(...) { ... } }
    q1 = """
    query($id:String!, $n:Int!, $after:String){
      project(id:$id){
        milestones(first:$n, after:$after){
          nodes { id name targetDate }
          pageInfo { hasNextPage endCursor }
        }
      }
    }"""
    # 2) Variant: project { projectMilestones(...) { ... } }
    q2 = """
    query($id:String!, $n:Int!, $after:String){
      project(id:$id){
        projectMilestones(first:$n, after:$after){
          nodes { id name targetDate }
          pageInfo { hasNextPage endCursor }
        }
      }
    }"""
    # 3) Root connection (filter by project id)
    #    Note: Filter syntax may vary across schema versions; this one works on current Linear.
    q3 = """
    query($id:String!, $n:Int!, $after:String){
      projectMilestones(first:$n, after:$after, filter:{ project: { id: { eq: $id } } }){
        nodes { id name targetDate }
        pageInfo { hasNextPage endCursor }
      }
    }"""

    for q, path in ((q1, ("project", "milestones")),
                    (q2, ("project", "projectMilestones")),
                    (q3, ("projectMilestones",))):
        try:
            data = gql(q, {"id": project_id, "n": 50, "after": after})
            conn = data
            for k in path:
                conn = conn[k]
            return conn  # Must have nodes[] and pageInfo{}
        except Exception:
            # Try next shape
            continue
    return None

def list_existing_milestone_names(project_id):
    """Return a set of existing milestone names on the project. Empty set if unsupported."""
    global MILESTONES_SUPPORTED
    names = set()
    cursor = None
    first_attempt = True
    while True:
        conn = _fetch_milestones_page(project_id, after=cursor)
        if conn is None:
            if first_attempt:
                MILESTONES_SUPPORTED = False
                print("Milestones API not available in this workspace/schema — skipping.", file=sys.stderr)
            return set()
        if first_attempt:
            MILESTONES_SUPPORTED = True
        first_attempt = False
        for m in conn.get("nodes") or []:
            nm = (m.get("name") or "").strip()
            if nm:
                names.add(nm)
        if not (conn.get("pageInfo") or {}).get("hasNextPage"):
            break
        cursor = (conn.get("pageInfo") or {}).get("endCursor")
    return names

def create_project_milestone(project_id, name, target_date=None, description=None):
    """
    Create a milestone if the mutation exists; otherwise return None.
    """
    global MILESTONES_SUPPORTED
    q = """
    mutation($input: ProjectMilestoneCreateInput!) {
      projectMilestoneCreate(input: $input) {
        success
        projectMilestone { id name targetDate }
      }
    }"""
    inp = {"projectId": project_id, "name": name}
    if target_date: inp["targetDate"] = target_date
    if description: inp["description"] = description
    try:
        out = gql(q, {"input": inp})["projectMilestoneCreate"]["projectMilestone"]
        time.sleep(0.02 + random.random() * 0.03)
        MILESTONES_SUPPORTED = True if MILESTONES_SUPPORTED is None else MILESTONES_SUPPORTED
        return out
    except Exception as e:
        # If the mutation itself isn't present, assume unsupported and bubble up a soft indicator
        MILESTONES_SUPPORTED = False
        raise

# ---------- States & completion ----------
def _team_states(team_id):
    """Fetch workflow states for a team, schema-tolerant (states vs workflowStates)."""
    for field in ("workflowStates", "states"):
        q = f"""
        query($id:String!){{
          team(id:$id){{
            {field}(first:100){{ nodes {{ id name type }} }}
          }}
        }}"""
        try:
            data = gql(q, {"id": team_id})
            st = data["team"].get(field, {}).get("nodes") or []
            if st:
                return st
        except Exception:
            pass
    return []

def find_completed_state_id(team_id):
    """Return the ID of a 'completed'/'done' state for the given team, if any."""
    for s in _team_states(team_id):
        t = (s.get("type") or "").lower()
        n = (s.get("name") or "").lower()
        if t == "completed" or n in ("done", "completed", "closed", "shipped"):
            return s["id"]
    return None

def mark_issue_completed(issue_id, team_id):
    """Mark an issue completed by moving it to a completed state (no completedAt field)."""
    done = find_completed_state_id(team_id)
    if not done:
        return False
    q = """
    mutation($id:String!, $input:IssueUpdateInput!){
      issueUpdate(id:$id, input:$input){ success }
    }"""
    gql(q, {"id": issue_id, "input": {"stateId": done}})
    time.sleep(0.05 + random.random() * 0.05)  # tiny jitter
    return True

# ---------- Project / Team helpers ----------
def find_team_by_key(key: str):
    data = gql("query($n:Int){ teams(first:$n){ nodes { id name key } } }", {"n": 200})
    teams = data["teams"]["nodes"]
    for t in teams:
        if t.get("key") == key:
            return t
    got = ", ".join(sorted([t.get("key","?") for t in teams]))
    sys.exit(f"Team key '{key}' not found. Available: {got}")

def find_project_by_name_exact(name: str):
    data = gql("query($n:Int){ projects(first:$n){ nodes { id name url } } }", {"n": 200})
    for p in data["projects"]["nodes"]:
        if p.get("name") == name:
            return p
    return None

def create_project(name, description=None, team_id=None, start_date=None, target_date=None):
    """
    Your workspace requires teamIds (list). We'll send teamIds and try with dates first,
    then fall back without dates if the schema rejects startDate/targetDate.
    """
    q = """
    mutation($input: ProjectCreateInput!) {
      projectCreate(input: $input) { success project { id name url } }
    }"""
    base = {"name": name, "teamIds": [team_id] if team_id else []}
    if description:
        base["description"] = description
    if start_date:
        base["startDate"] = start_date
    if target_date:
        base["targetDate"] = target_date

    last_err = None
    for try_dates in (True, False):
        inp = dict(base)
        if not try_dates:
            inp.pop("startDate", None)
            inp.pop("targetDate", None)
        try:
            return gql(q, {"input": inp})["projectCreate"]["project"]
        except RuntimeError as e:
            last_err = e
            continue
    raise last_err

# ---------- Issues ----------
def create_issue(team_id, title, description=None, project_id=None, project_milestone_id=None):
    q = """
    mutation($input: IssueCreateInput!) {
      issueCreate(input: $input) { success issue { id identifier url } }
    }"""
    inp = {"teamId": team_id, "title": (title or "")[:240]}
    if description:           inp["description"] = description
    if project_id:            inp["projectId"] = project_id
    if project_milestone_id:  inp["projectMilestoneId"] = project_milestone_id
    created = gql(q, {"input": inp})["issueCreate"]["issue"]
    time.sleep(0.01 + random.random() * 0.03)  # jitter
    return created

def issue_update(issue_id, input_obj):
    q = """
    mutation($id:String!, $input: IssueUpdateInput!) {
      issueUpdate(id:$id, input:$input) { success issue { id } }
    }"""
    resp = gql(q, {"id": issue_id, "input": input_obj})
    time.sleep(0.01 + random.random() * 0.03)  # jitter
    return resp

def attach_external_link(entity_id, title, url):
    if not url:
        return
    q = """
    mutation($input: EntityExternalLinkCreateInput!) {
      entityExternalLinkCreate(input:$input){ success }
    }"""
    gql(q, {"input": {"entityId": entity_id, "title": (title or "Link"), "url": url}})
    time.sleep(0.01 + random.random() * 0.02)

# ---------- CLI ----------
def main():
    ap = argparse.ArgumentParser()
    ap.add_argument("--plan", required=True, help="Path to enriched plan JSON")
    ap.add_argument("--team-key", required=True, help="Linear team key, e.g. PRE")
    ap.add_argument("--reuse-project-if-exists", action="store_true")
    ap.add_argument("--skip-milestones", action="store_true", help="Do not create milestones")
    ap.add_argument("--skip-issues", action="store_true", help="Do not create issues")
    args = ap.parse_args()

    plan = json.load(open(args.plan, "r", encoding="utf-8"))

    # Team
    team = find_team_by_key(args.team_key)
    team_id = team["id"]

    # Project metadata
    proj_meta = plan.get("project", {}) or {}
    proj_name = proj_meta.get("name") or "Imported Project"
    desc = (proj_meta.get("description") or "").strip()
    overview = (plan.get("overview") or "").strip()
    if overview:
        desc = (desc + ("\n\n---\nOverview:\n" if desc else "Overview:\n") + overview).strip()

    # Create or reuse project
    project = find_project_by_name_exact(proj_name) if args.reuse_project_if_exists else None
    if not project:
        project = create_project(
            name=proj_name,
            description=desc if desc else None,
            team_id=team_id,
            start_date=proj_meta.get("start_date"),
            target_date=proj_meta.get("target_date"),
        )
    print(f"Project: {project['name']}  {project['url']}")

    # Milestones
    ms_map = {}
    ms_failed = 0
    ms_skipped = 0
    ms_unavailable = False

    if not args.skip_milestones:
        try:
            existing = list_existing_milestone_names(project["id"])
            if MILESTONES_SUPPORTED is False:
                ms_unavailable = True
        except Exception as e:
            print(f"Milestones not supported or listing failed — skipping. {e}", file=sys.stderr)
            ms_unavailable = True
            existing = set()

        if not ms_unavailable:
            for m in (proj_meta.get("milestones") or []):
                name = (m.get("name") or "").strip()
                if not name:
                    continue
                if name in existing:
                    ms_skipped += 1
                    print(f"Milestone exists, skipping: {name}")
                    ms_map[name] = None
                    continue
                try:
                    pm = create_project_milestone(
                        project_id=project["id"],
                        name=name,
                        target_date=m.get("target_date"),
                        description=m.get("description"),
                    )
                    existing.add(name)
                    ms_map[name] = pm["id"]
                    print(f"Milestone created: {pm['name']} ({pm.get('targetDate') or ''})")
                except Exception as e:
                    ms_failed += 1
                    print(f"WARNING: milestone failed: {name} — {e}", file=sys.stderr)

    # Issues
    created, failed = 0, 0
    if not args.skip_issues:
        for idx, it in enumerate(plan.get("issues") or [], 1):
            try:
                # Optional milestone mapping by name (best-effort if API unsupported)
                ms_id = None
                ms_name = (it.get("milestone") or "").strip()
                if ms_name and not ms_unavailable:
                    ms_id = ms_map.get(ms_name)

                issue = create_issue(
                    team_id=team_id,
                    title=it.get("title"),
                    description=it.get("description"),
                    project_id=project["id"],
                    project_milestone_id=ms_id,
                )
                created += 1

                # Labels + due date
                wanted = list(dict.fromkeys([(l or "").strip() for l in (it.get("labels") or []) if l]))
                label_ids = [lid for lid in (ensure_label(n, team_id) for n in wanted) if lid]
                updates = {}
                if label_ids:           updates["labelIds"] = label_ids
                if it.get("due_date"):  updates["dueDate"] = it["due_date"]  # YYYY-MM-DD
                if updates:
                    issue_update(issue["id"], updates)

                # Completion: move to Completed state if requested (cannot backdate completedAt)
                if it.get("completed_at"):
                    mark_issue_completed(issue["id"], team_id)

                # External links (e.g., commit URL)
                for link in (it.get("external_links") or []):
                    attach_external_link(issue["id"], link.get("title"), link.get("url"))

                if created % 20 == 0:
                    print(f"...created {created} issues so far")

            except Exception as e:
                failed += 1
                print(f"WARNING: issue failed ({it.get('title','(no title)')[:80]}): {e}", file=sys.stderr)

    if MILESTONES_SUPPORTED is False:
        print("Note: Milestones API not available in this workspace/schema — milestones were skipped.", file=sys.stderr)

    print(f"Done. Milestones failed: {ms_failed}. Milestones skipped: {ms_skipped}. Issues created: {created}. Issues failed: {failed}.")

if __name__ == "__main__":
    main()
